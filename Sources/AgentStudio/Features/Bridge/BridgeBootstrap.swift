import Foundation

/// Generates the JavaScript bootstrap script injected into the bridge content world.
///
/// This script runs at document start in the bridge world (not page world).
/// It installs `window.__bridgeInternal` with relay functions for state pushes,
/// listens for commands from page world with nonce validation, and handles the
/// bridge.ready handshake.
///
/// Design doc: handshake (§4.5), nonce security (§11.3), bootstrap injection (§9.1).
enum BridgeBootstrap {

    /// Generate the bootstrap JavaScript for a bridge pane.
    ///
    /// - Parameters:
    ///   - bridgeNonce: Nonce for validating commands from page world (§11.3).
    ///     Page world must include this nonce in `__bridge_command` events.
    ///   - pushNonce: Nonce sent to page world in handshake for push event validation.
    ///     Page world uses this to verify incoming `__bridge_push` events.
    /// - Returns: JavaScript source string to inject as WKUserScript in bridge content world.
    static func generateScript(bridgeNonce: String, pushNonce: String) -> String {
        """
        // Bridge Bootstrap — injected at document start in bridge content world.
        // DO NOT EDIT this output directly — generated by BridgeBootstrap.swift.
        (function() {
            'use strict';

            const BRIDGE_NONCE = '\(bridgeNonce)';
            const PUSH_NONCE = '\(pushNonce)';

            // Install bridge internal API in bridge world only.
            // Page world cannot access this (content world isolation).
            window.__bridgeInternal = {
                // Push state to page world via CustomEvent.
                // Envelope metadata (__revision, __epoch) is lifted to detail level
                // so receiver-side stale/epoch guards work without nested unwrapping.
                merge: function(store, data, revision, epoch) {
                    document.dispatchEvent(new CustomEvent('__bridge_push', {
                        detail: { op: 'merge', store: store, data: data, __revision: revision, __epoch: epoch, nonce: PUSH_NONCE }
                    }));
                },
                replace: function(store, data, revision, epoch) {
                    document.dispatchEvent(new CustomEvent('__bridge_push', {
                        detail: { op: 'replace', store: store, data: data, __revision: revision, __epoch: epoch, nonce: PUSH_NONCE }
                    }));
                },
                applyEnvelope: function(envelope) {
                    const op = envelope.op || 'replace';
                    const revision = envelope.__revision;
                    const epoch = envelope.__epoch;
                    const store = envelope.store;
                    // Forward envelope as data with metadata lifted to detail level.
                    if (op === 'merge') {
                        this.merge(store, envelope, revision, epoch);
                    } else {
                        this.replace(store, envelope, revision, epoch);
                    }
                },
                appendAgentEvents: function(events) {
                    document.dispatchEvent(new CustomEvent('__bridge_agent', {
                        detail: { events: events, nonce: PUSH_NONCE }
                    }));
                },
                response: function(id, result, error) {
                    document.dispatchEvent(new CustomEvent('__bridge_response', {
                        detail: { id: id, result: result, error: error, nonce: PUSH_NONCE }
                    }));
                }
            };

            // Listen for commands from page world — validate nonce before forwarding to Swift.
            // Design doc §4.2: page world sends { jsonrpc, method, params, __nonce }.
            // Bridge world validates __nonce, strips it, and forwards the rest as stringified JSON.
            document.addEventListener('__bridge_command', function(event) {
                const detail = event.detail;
                if (!detail || detail.__nonce !== BRIDGE_NONCE) {
                    return; // Reject commands without valid nonce
                }
                // Strip nonce before forwarding to Swift
                const { __nonce, ...payload } = detail;
                window.webkit.messageHandlers.rpc.postMessage(JSON.stringify(payload));
            });

            // Listen for bridge.ready from page world
            document.addEventListener('__bridge_ready', function(event) {
                // Relay to Swift — this triggers push plan start
                window.webkit.messageHandlers.rpc.postMessage(
                    JSON.stringify({ jsonrpc: '2.0', method: 'bridge.ready', params: {} })
                );
            });

            // Dispatch handshake to page world with push nonce.
            // Page world needs this to validate incoming push events.
            document.dispatchEvent(new CustomEvent('__bridge_handshake', {
                detail: { pushNonce: PUSH_NONCE }
            }));

            // Replay handshake for late page-world listeners (P1 fix).
            // The initial __bridge_handshake fires at document start, but the React
            // bundle typically loads later and misses it. Page world can dispatch
            // __bridge_handshake_request to receive a replayed __bridge_handshake.
            document.addEventListener('__bridge_handshake_request', function() {
                document.dispatchEvent(new CustomEvent('__bridge_handshake', {
                    detail: { pushNonce: PUSH_NONCE }
                }));
            });

            // Set nonce attribute on documentElement for page world command sender
            document.documentElement.setAttribute('data-bridge-nonce', BRIDGE_NONCE);
        })();
        """
    }
}
